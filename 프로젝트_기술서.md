## 1. 현재까지의 작업 상태

[Langgraph Agent Node 구성]
1. START 
    - 입력 : 사용자의 요청(task) 
    - 처리 : 사용자의 입력 요청을 받아서 agent_state의 task에 저장
    - 출력 : 없음 
    - 상태 : task 업데이트
    - 기타 : Clarify 노드로 이동
2. Clarify 노드
    - 입력 : 사용자의 입력(task)
    - 처리 : llm이 사용자의 요청에서 agent 자동화 처리에 누락된 정보가 있으면 사용자에게 추가 정보 요청
    - 출력 : 
        1. need_clarification = True인 경우
            - question (사용자에게 추가 요청할 질문)
        2. need_clarification = False인 경우
            - message_to_user (더이상 보강할 필요 없고 planning 노드로 이동하겠다는 메시지)
    - 상태 : messages 업데이트 
    - 기타 : get_command_destination을 통해 아래 3가지 routing 분기로 이동 
        1. 사용자에게 질문을 요청할 시 -> clarify 노드
        2. 더이상 보강할 필요 없을 시 -> planning 노드
        3. 기타 상황 발생 시 -> END 노드 (근데 로직 상 여기로 이동할 경우는 없음 planning 노드 때문에 이렇게 처리함)

3. Planning 노드
    - 입력 : 사용자와 나눈 messages (사용자의 초기 요청 + 추가 정보)
    - 처리 : 사용자와 나눈 대화 토대로 상세 plan 수립
    - 출력 : plan 스키마에 맞춘 List[str] 타입의 plan
    - 상태 : plan 업데이트 
    - 기타 : human approval 노드로 이동

4. Human Approval 노드
    - 입력 : 사용자와 나눈 messages (사용자의 초기 요청 + 추가 정보)
    - 처리 : 사용자와 나눈 대화 토대로 상세 plan 수립
    - 출력 : 사용자에게 User approval 요청 (yes/no)
    - 상태 : messages에 업데이트
    - 기타 : get_command_destination을 통해 아래 분기로 routing
        1. yes -> agent 
        2. no -> feedback -> planning
        3. 다른 입력(Agent를 그만 둘지 물어봄) -> (1) yes 시, END, (2) no 시, human approval

5. Agent 노드
    - 입력 : messages 중 browser_snapshot 결과 만들어진 html 파싱 결과를 제외한 나머지 내용들 (단, 마지막 message가 browser_snapshot 결과인 경우에는 html 파싱 결과도 가져옴, 왜냐하면 agent가 tool 호출 또는 사고 과정에 스냅샷 결과가 필요하다고 판단해 직전에 browser_snapshot을 호출했을 거기 때문에)
    - 처리 : agent가 지금까지의 message를 토대로 각 스텝별로 필요한 tool호출을 진행
    - 출력 : tool_calls 결과 
    - 상태 : messages에 업데이트
    - 기타 : should_continue를 통해 아래 3가지 분기로 라우팅
        1. 마지막 메시지에 tool_calls가 있으면 -> tool 노드
        2. tool_calls는 없지만, 아직 plan 단계가 남아있으면 -> agent
    - 에러 핸들링 : MAX_TOKENS 이슈 여부에 따라 점진적으로 메시지 사이즈를 줄여 나가는 처리 진행

6. Tool 노드
    - 입력 : state와 tool_executor
    - 처리 : state의 마지막 message에서 tool_calls 리스트를 가져와 tool_exeutor로 실행한 후 반환
    - 출력 : 아래 사용한 tool에 따라 반환 결과가 달라짐
        1) think_tool인 경우 -> result, current_plan_step
        2) mcp_playwright_tool들인 경우 -> result, none 리턴
    - 기타 : 사용가능한 tool 목록
        1) mcp_playwright_tool : playwright의 브라우저 작업을 위한 mcp도구
        2) think_tool : react 에이전트를 위한 사고 도구
        3) extracted_data_tool : report 노드 단게에서 사용자에게 답변하기 위해 필요한 정보를 중간 중간 저장하는 도구

7. Report 노드
    - 입력 : 기획 중
    - 처리 : 기획 중
    - 출력 : final_answer, workflow_summary
    - 기타 : 기획 중

8. END
    - 입력 : agent_state 
    - 처리 : agent_state에서 final_answer과 workflow_summary 중 필요한 정보를 사용자에게 console 통해 알려줌
        1) 사용자가 웹 작업만 요청했을 시 -> workflow_summary 
        2) 사용자가 웹 작업을 통한 결과물을 요청했을 시 -> final_answer + workflow_summary
    - 출력 : 
    - 기타 : 


[Agent State 구성]
- task : str 
- messages : Annotated[List[AnyMessage], operator.add]
- plan : List[str]
- current_plan_step : int 
- action_history : Annotated[List[str], operator.add]
- last_error : Optional[str]
- extracted_data : Annotated[Dict[str, Any], operator.ior]
- final_answer : str 
- workflow_summary : str 
- max_messages_for_agent: Optional[int] = 5

[Clarification 스키마]
- need_clarification : bool
- question : str 
- message_to_user : str

[Plan 스키마]
- steps : List[str]


## 2. 앞으로 처리해야 될 것들 (todo)
1. 스냅샷 결과 처리
    - (문제) 현재는 browser_snapshot을 통해 가져온 html 파싱 결과를 messages에 저장하고 있는데, 이렇게 되면 messages에 계속 파싱 결과들이 누적되면서 agent state의 길이(메모리 문제)가 길어지고, 이에 따라 agent_node에서 messages를 다 가져오다보니 MAX_TOKENS 오류에 계속 빠지게 됨 
    - (해결) browser_snapshot 결과는 따로 agent_state에서 필드로 관리(가칭은 last_snapshot)하고자 함. 그리고 스냅샷 결과가 필요할 때마다 가져와서 사용하고, 새로 browser_snapshot으로 스냅샷 결과를 가져오면 agent_state에서 새로운 스냅샷 결과로 갱신

2.  extracted_data_tool 추가
    - (문제) 현재 agent가 browser 자동화 처리를 하면서 중간중간 사용자에게 답변할 때 필요한 정보를 따로 저장하지 않고 있음.. 이렇게 되면, 결국 마지막 report 노드에서 사용자에게 답변할 때 중간에 찾은 결과물들을 몰라 답변하지 못하는 문제에 봉착
    - (해결) 중간 중간 찾은 정보들을 agent_state에 저장할 수 있도록 따로 extracted_data_tool을 만들어 호출하도록 함. 

3. Report 노드 추가
    - (문제) web 자동화 작업이 끝난 후 작업 결과를 사용자에게 보고하고 있지 않음 따라서 사용자는 도대체 agent가 어떤 과정을 통해 작업을 했고, agent에게 요청한 task에 대한 결과를 알수가 없음
    - (해결) 최종 END노드 직전에 report 노드를 추가해서 agent가 agent_state에 있는 plan, extracted_data 필드 등을 참고해서 작업 과정을 토대로 결과 보고(사용자가 알아내라고 한 정보, 웹 자동화 작업의 요약)하도록 함. 

4. 현재 고민 중인 부분
    1) State를 2개로 분리할지 말지 고민 중
        - (배경) 현재 agent의 모든 부분에서 AgentState가 상태 관리에 사용되고 있는데... Clarify + Planning 단계와 Agent + Tool + Report 단계에서 messages 필드가 같이 공유되어 있음.. 하지만 agent 단계에서부터는 clarify와 planning 단계에서 저장된 messages가 필요 없음. 왜냐하면 이미 clarify와 planning 단계에서 얻은 정보들은 모두 plan 필드에서 포함되어 있기 때문이고, agent 노드에서부터는 plan 필드를 사용해서 작업을 수행하고 있음

    2) Human In the Loop의 더 고도화된 처리
        - (배경) 현재 agent workflow 작업에서 사용자가 개입하는 단계는 총 2번 있음.. clarify 노드와 plannning 노드에서 추가적인 정보와 plan 피드백 제공을 위해 중간에 개입하는데... 이 개입 단계에서 human_approval이라는 노드가 사용되고 있는데 하지만 clarify 노드에서는 노드 자체에서 인간 개입이 처리됨... 이러한 방식이 실행에서는 큰 문제는 안 되지만 agent 설계(아키텍처) 관점에서는 깔끔하지 않음...